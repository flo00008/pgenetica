"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const randexp_1 = __importDefault(require("randexp"));
const seedrandom_1 = __importDefault(require("seedrandom"));
class Parser {
    constructor(Override) {
        this.Options = {
            OverrideRules: {},
            Rules: [],
            Start: 'ParserStart',
            MaxStack: 25,
            MaxLoops: 500,
            Filter: () => true,
        };
        this.Output = '';
        this.StopRecusiveRules = false;
        this.SetSeed = (Seed) => seedrandom_1.default(Seed, { global: true });
        this.RandInt = (Range) => Math.floor(Math.random() * Range);
        this.RandomArrayElement = (Arr) => {
            const Idx = this.RandInt(Arr.length);
            const Item = Arr[Idx];
            return Item;
        };
        this.SelectRule = (RuleName) => {
            const Rules = this.Options.Rules.filter(({ name }) => name === RuleName);
            if (Rules.length === 0)
                throw new Error(`Nothing matches rule: ${RuleName}!`);
            const Filtered = Rules.filter(Rule => {
                if (!this.Options.Filter(Rule))
                    return false;
                if (this.StopRecusiveRules || this.Stack.length > this.Options.MaxStack)
                    return !Rule.symbols.includes(RuleName);
                return true;
            });
            return this.RandomArrayElement(Filtered);
        };
        this.Parse = () => {
            let Count = 0;
            while (this.Stack.length > 0) {
                Count++;
                if (!this.StopRecusiveRules && Count > this.Options.MaxLoops)
                    this.StopRecusiveRules = true;
                const RuleName = this.Stack.pop();
                const Overrides = Object.keys(this.Options.OverrideRules);
                if (Overrides.includes(RuleName))
                    this.Stack.push({ literal: this.Options.OverrideRules[RuleName]() });
                else if (typeof RuleName === 'string')
                    this.SelectRule(RuleName).symbols.forEach(Symb => this.Stack.push(Symb));
                else if (RuleName.test)
                    this.Output = new randexp_1.default(RuleName).gen() + this.Output;
                else if (RuleName.literal)
                    this.Output = RuleName.literal + this.Output;
            }
            return this.Output;
        };
        Object.assign(this.Options, Override);
        this.Stack = [this.Options.Start];
    }
}
exports.default = Parser;
//# sourceMappingURL=index.js.map